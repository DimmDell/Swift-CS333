<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Swift-CS333. Swift Syntax. Part 2</title>

		<link rel="stylesheet" href="../css/reveal.css">
		<link rel="stylesheet" href="../css/theme/swift.css">
		<!-- Theme used for syntax highlighting of code included in main theme -->
		<!-- Printing and PDF exports -->
		<script type="text/javascript">
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? '../css/print/pdf.css' : '../css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
 		</script>
		<style>
		#swift-bird{
			-webkit-clip-path: polygon(10% 0%, 65% 0, 85% 100%, 30% 100%);
			clip-path: polygon(10% 0%, 65% 0, 85% 100%, 30% 100%);
			max-width:100%;
			/*max-height: 100%*/
		}
		</style>
	</head>
	<body>
		<div class="reveal">
			<div class="topbar">
				<div class="breadcrumbs">
				</div>
			</div>
			<div class="slides">
				<section>
					<h2>CS333</h2>
					<h1>Mobile Development</h1>
					<p>
						</br>Ilya Loshkarev</br>
						<a href="mailto:loshkarev.i@gmail.com">loshkarev.i@gmail.com</a>
					</p>
					<p class="footer">
						<br>SFEDU 2016
					</p>
				</section>
				<section>
					<h3 class="hidden">Overview</h3>
					<div class="row">
						<div class="col">
						<ul>
							<li>
								<a href="#/2">Initialization</a>
							</li>
							<li>
								<a href="#/3">Protocols</a>
							</li>
							<li>
								<a href="#/4">Extentions</a>
							</li>
							<li>
								<a href="#/5">Enumerations</a>
							</li>
							<li>
								<a href="#/6">Standart Library</a>
							</li>
						</ul>
						</div>
						<div class="col">
							<img id="swift-bird" src="../img/swift-bird.jpg" />
						</div>
					</div>
				</section>
<!-- Initialization				-->
				<section class="">
					<section data-background="../img/swift-og.png">
						<h1>Initialization</h1>
					</section>
					<section>
						<h3>Structure Initialization</h3>
						<pre><code data-noheader>
							struct Point {
								var x = 0.0, y = 0.0
							}
							struct Size {
								var width = 0.0, height = 0.0
							}
							let p = Point(x: 1.0, y: 1.0)
						</code></pre>
						<p class="notice">
							Structures have default memberwise initializers
						</p>
					</section>
					<section>
						<h3>Class Initialization</h3>
						<pre><code data-noheader>
							class Rect {
								var origin = Point()
								var size = Size()
								init() {}
								init(origin: Point, size: Size) {
									self.origin = origin
									self.size = size
								}
							}
						</code></pre>
						<p class="notice">
							Classes don't have default memberwise initialisers
						</p>
					</section>
					<section>
						<h3>Two Kinds of Initializers</h3>
						<pre><code data-noheader>
								init(origin: Point, size: Size) { // designated init
									self.origin = origin
									self.size = size
								}
						</code></pre>
						<p>
							<span class="emphasis">Designated initializer</span> fully initializes all proprties of the class
						</p>
						<pre><code data-noheader>
							convenience init(center: Point, size: Size) {
								let originX = center.x - (size.width / 2)
								let originY = center.y - (size.height / 2)
								self.init(origin: Point(x: originX, y: originY), size: size)
							}
						</code></pre>
						<p>
							<span class="emphasis">Convenience initializer</span> covers specific use case <br> of initialization parameters
						</p>
					</section>
					<section>
						<h3>Rules of Class Initialization</h3>
						<ul>
							<li class="notice">
								Any designated initializer must call a designated initializer <br> from its superclass
							</li>
							<li class="notice">
								Any convenience initializer must call another initializer <br> from the same class
							</li>
							<li class="notice">
								Any convenience initializer must ultimately call <br> a designated initializer
							</li>
						</ul>
					</section>
					<section>
						<h3>Initializer Delegation</h3>
						<pre><code data-noheader>
							class TextBox: Rect {
								var text: String = ""
								init(text: String, origin: Point, size: Size) { //designated init
									super.init(origin: origin, size: size)
									self.text = text;
								}
								convenience init(text: String, center: Point, size: Size) {
									let originX = center.x - (size.width / 2)
									let originY = center.y - (size.height / 2)
									self.init(text: text, origin: Point(x: originX, y: originY),
										size: size)
								}
							}
						</code></pre>
					</section>
					<section>
						<h3>Initializer Inheritance</h3>
						<pre><code data-noheader>
							class TextBox: Rect {
								var text: String = ""
								convenience init(text: String, origin: Point, size: Size) {
									self.init(origin: origin, size: size)
									self.text = text
								}
							}
							var t = TextBox()
						</code></pre>
					</section>
					<section>
						<h3>Required Initializers</h3>
						<pre><code data-noheader>
							class Rect {
								required init(){}
							}
							class TextBox {
								required init(){
									super.init()
								}
							}
							</code></pre>
					</section>
					<section>
						<h3>Failable Initialization</h3>
						<pre><code data-noheader>
							class TextBox: Rect {
								init? (text: String){
									if text.characters.count == 0 { return nil }
									super.init()
								}
							}
						</code></pre>
					</section>
				</section>
<!-- Protocols    	  -->
        <section>
          <section data-background="../img/swift-og.png">
            <h1>Protocols</h1>
          </section>
          <section>
            <h3>Protocol Rquirements</h3>
            <pre><code data-noheader>
							protocol IntContainer {
								var count: UInt { get }
								subscript(index: Int) -> Int { get }
								mutating func append(item: Int)
							}
            </code></pre>
            <p>
							Protocols list methods and properties reqiered for implementation
            </p>
          </section>
          <section>
            <h3>Conforming to protocol</h3>
            <pre><code data-noheader>
              class IntStack: IntContainer {
								let elements: [Int]
								var count {
									return elements.count
								}
								subscript(index: Int) -> Int {
									return elements[index]
								}
								func
							}
            </code></pre>
            <p>
              Function's type consists of <br> types of parameters and return value
            </p>
          </section>
					<section>
						<h3>Operators</h3>
						<pre><code data-noheader>
							func +(_ left: Bool, _ right: Bool) {
								return left || right
							}
							let a = true, b = false
							let c = a + b
						</code></pre>
					</section>
          <section>
            <h3>Nested Functions</h3>
            <pre><code data-noheader>
              func counter(forward: Bool) -> (Int) -> Int {
                func stepForward(input: Int) -> Int {
                  return input + 1
                }
                func stepBackward(input: Int) -> Int {
                  return input - 1
                }

                return forward ? stepForward : stepBackward
              }
            </code></pre>
          </section>
        </section>
<!-- Extentions				-->
        <section>
          <section data-background="../img/swift-og.png">
            <h1>Extentions</h1>
          </section>
					<section>
						<h3>Extending basic structures</h3>
						<pre><code data-noheader>
							extension Int {
									mutating func square() {
											self = self * self
									}
								func repeatitions(task: () -> Void) {
										for _ in 0..&lt;self {
												task()
										}
									}
							}
						</code></pre>
					</section>
          <section>
            <h3>Closing over context</h3>
            <pre><code data-noheader>
              func counter(increment: Int, forward: Bool) -> (Int) -> Int {

                func backward(input: Int) -> Int {
                  return input - increment
                }

                return !forward ? backward :
                  { (input: Int) -> Int in return input + increment }
              }
            </code></pre>
            <p>
              Closures are blocks of code that can capture <br>local constants and variables
            </p>
          </section>
          <section>
            <h3>Local context</h3>
            <pre><code data-noheader>
              // global function
              func counter(increment: Int, forward: Bool) -> (Int) -> Int {
                // local function &ndash; increment is captured
                func backward(input: Int) -> Int {
                  return input - increment
                }

                return !forward ? backward :
                // closure expression &ndash; increment is captured
                  { (input: Int) -> Int in return input + increment }
              }
            </code></pre>
            <p>
              Local functions and closure expressions <br>can capture any value in context
            </p>
            <p>
              Global functions don't capture any values
            </p>
          </section>
          <section>
            <h3>Closure Expression</h3>
            <pre><code data-noheader>
              let names = ["Anna", "Ivan", "Maria", "John"]

              var reversedNames = names.sorted(by: {
                  (s1: String, s2: String) -> Bool in
                    return s1 > s2
              })
            </code></pre>
            <p>
              Closure expression &ndash; unnamed block of executable code <br> that can capture values from local context
            </p>
          </section>
          <section>
            <h3>Brevity of a closure</h3>
            <div class="row">
              <pre><code data-noheader>
                var reversedNames = names.sorted(by:
                  { s1, s2 in return s1 > s2 })
              </code></pre>
              <p>
                Parameter types can be inferred from context
              </p>
            </div>
            <div class="row">
              <pre><code data-noheader>
                var reversedNames = names.sorted(by: { return $0 > $1 })
              </code></pre>
              <p>
                Parameters can be referenced by shorthand names
              </p>
            </div>
            <div class="row">
              <pre><code data-noheader>
                var reversedNames = names.sorted(by: { $0 > $1 })
              </code></pre>
              <p>
                Single-expression closure implicitly returns its result
              </p>
            </div>
          </section>
          <section>
            <h3>Even shorter</h3>
						<div class="row">
	            <pre><code data-noheader>
	              var reversedNames = names.sorted { $0 > $1 }
	            </code></pre>
	            <p>
	              Closure can be passed with trailing syntax
	            </p>
						</div>
						<div>
	            <pre><code data-noheader>
	              var reversedNames = names.sorted(by: >)
	            </code></pre>
	            <p>
	              Any operator is a function
	            </p>
						</div>
          </section>
          <section>
            <h3>Sharing a variable</h3>
            <pre><code data-noheader>
              func counter(withIncrement: Int) -> () -> Int {
                var totalCount = 0
                return { totalCount += withIncrement }
              }

              let newCounter = counter(withIncrement: 10)
              print(newCounter()) // 10
              let anotherCounter = newCounter
              print(anotherCounter()) // 20
            </code></pre>
            <p class = "notice">
              Closures are reference type
            </p>
          </section>
          <section>
            <h3>Autoclosures</h3>
            <pre><code data-noheader>
              var names = ["Anna", "Ivan", "Maria", "John"]
              let nextInLine = { names.remove(at:0) }

              print("Next one is \(nextInLine()!") // Anna!
              print(names.count) // 3

              func whosNext(provider nextInLine: @autoclosure () -> String) {
                print("Next one is \(nextInLine())")
              }
              whosNext(provider: names.remove(at:0))
            </code></pre>
            <p>
              <code class="hljs-attribute">@autoclosure</code> automaticaly wraps parameter <br> in closure expression
            </p>
          </section>
        </section>
<!-- Enumerations      -->
				<section>
          <section data-background="../img/swift-og.png">
            <h1>Enumerations</h1>
          </section>
					<section>
						<h3>Classes and Structures</h3>
						<pre><code data-noheader>
							struct Point {
								var x = 0.0, y = 0.0
							}

							class Polygon {
								let points: [Point]
								init (_ points: [Point]) {
									self.points = points
								}
								var center: Point {
									/* Calculate center */
									return Point(x: xVal, y:yVal)
								}
							}
						</code></pre>
						<p>
							Classes are reference type
						</p>
						<p>
							Structures are value type and can not be inherited
						</p>
					</section>
					<section>
						<h3>Properties</h3>
						<pre><code data-noheader>
							class Polygon {
								let points: [Point]  // has to be set in initializer
								let name = "polygon" // has a default value
								var area: Double {  // read-only property
									/* Calculate area */
								}
								var origin: Point {
									get {/* do something */}
									set(newOrigin) {/* do something */}
								}
							}
						</code></pre>
					</section>
					<section>
						<h3>Methods</h3>
						<pre><code data-noheader>
							struct Point {
								mutating func offset(_ xStep: Double, _  yStep: Double) {
									/* Change x, y */
								}
								func distance(_ to: Point) -> Double {
									/* Calculate distance */
								}
							}
							class Polygon {
								func contains(_ p: Point) -> Bool {
									/* do something */
								}
							}
						</code></pre>
						<p>
							Structure methods that change properties has to be marked <code class="hljs-keyword">mutating</code>
						</p>
					</section>
					<section>
						<h3>Access Control</h3>
						<pre><code data-noheader>
							class Shady { // implicitly internal
								 private var things: [String] = []
								 private func stuff() {}
								 func allClear() {} // implicitly internal
								 public var totallyClear: String
							}
							private class Classified { // explicitly private
								var nothing: String // implicitly private
							}
						</code></pre>
						<p class="notice">
							All classes and class members are implicitly <code class="hljs-keyword">internal</code>
						</p>
					</section>
					<section>
						<h3>Automatic Reference Counting</h3>
						<pre><code data-noheader>
							class ARCout {
								init(){
									print ("initialized")
								}
								deinit() {
									print ("deinitialized")
								}
							}
							var reference1: ARCout? = ARCout() // initialized
							var reference2 = reference1
							reference1 = nil
							reference2 = nil // deinitialized
						</code></pre>
						<p>
							Deallocates memory if no references to object exists
						</p>
					</section>
					<section>
						<h3>Reference Loops</h3>
						<pre><code data-noheader>
							class ARCout {
								var reference: ARCout?
							}
							var obj1 = ARCout() // initialized
							var obj2 = ARCout() // initialized
							obj1.reference = obj2
							obj2.reference = obj1
							obj1 = nil
							obj2 = nil
							// But nothing happened!
						</code></pre>
						<pre><code data-noheader>
							class ARCout {
								weak var reference: ARCout?
							}
						</code></pre>
						<p>
							<code class="hljs-keyword">weak</code> references don't increase retain count
						</p>
						<p>
							<code class="hljs-keyword">unowned</code> references don't have to be optional values
						</p>
					</section>
					<section>
						<h3>Inheritance</h3>
						<pre><code data-noheader>
							class Triangle: Polygon {
								init(_ a: Point, _ b: Point, _ c: Point) {
									let verts = [a,b,c]
									super.init(verts)
									name = "triangle"
								}
								override var area: Double {
									/* Calculate area */
								}
								func inradius: Double {
									/* Calculate incircle radius */
								}
							}
						</code></pre>
						<p>
							<code class="hljs-keyword">super</code> provides access to superclass members
						</p>
						<p class="notice">
							Any overwritten member should be marked with <code class="hljs-keyword">override</code>
						</p>
					</section>
					<section>
						<h3>Type Casting</h3>
						<pre><code data-noheader>
							let shapes = [Polygon]()
							/* appended something to shapes */
							for shape in shapes {
								if shape is Triangle {
									print("it's a triangle")
								}
							}

							for shape in shapes {
								if let tri = shape as? Triangle {
									print(tri.inradius)
								}
							}
							</code></pre>
							<p>
								<code class="hljs-keyword">as?</code> wraps result into optional,	<br> returns <code class="hljs-literal">nil</code> if variable cannot be downcasted
							</p>
							<p>
								<code class="hljs-keyword">as!</code> triggers a runtime error instead
							</p>
					</section>
        </section>
<!-- Standart Library -->
				<section>
					<section data-background="../img/swift-og.png">
						<h1>Standart Library</h1>
					</section>
					<section>
						<h3>Array</h3>
						<pre><code data-noheader>
							enum MyErrors: ErrorType {
								case OutOfOptions
							}
							func chooseOption() throws -> Int {
								throw MyErrors.OutOfOptions
							}
						</code></pre>
						<p class="notice">
							Only throwing functions can throw and propagate errors
						</p>
					</section>
					<section>
						<h3>Dictionary</h3>
						<pre><code data-noheader>
							do {
								var option = try chooseOption()
							}
							catch MyErrors.OutOfOptions {
								print("I'm all out of options here!")
							}
						</code></pre>
						<p>
							<code class="hljs-keyword">try</code> can only be used in <code class="hljs-keyword">do-catch</code> block
						</p>
						<p>
							<code class="hljs-keyword">do-catch</code> block stops error propagation <br> if it catches an error
						</p>
					</section>
					<section>
						<h3>Set</h3>
						<pre><code data-noheader>
							var option = try? chooseOption() // Int?

							func makeAnOption() -> Int {
								var option = try! chooseOption() // just do it
								return option
							}
						</code></pre>
						<p>
							<code class="hljs-keyword">try?</code> wraps value into an optinal, retruns <code class="hljs-literal">nil</code> if error occurs
						</p>
						<p>
							<code class="hljs-keyword">try!</code> fails here and now, stops error popagation
						</p>
					</section>
					<section>
						<h3>Guard</h3>
						<pre><code data-noheader>
							guard let option = try? chooseOption() else {
								print("Sorry, we're out of options!")
								return
							}
							print("Congratulations, your option is \(option)")
						</code></pre>
						<p>
							<code class="hljs-keyword">guard</code> is assert-like operator that allow quick escape <br> if condition is not met
						</p>
						<p class = "notice">
							guard-bound optional is accesible outside of it's else clause
						</p>
					</section>
				</section>
<!-- Resources			-->
				<section>
					<h3 style="display:none;">Related Resources</h3>
					<ul>
						<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html">Swift Programming Language - Apple Developer</a>
						</li>
						<li><a href="https://developer.apple.com/reference/swift">Swift Standart Library - Apple Developer</a>
						</li>
					</ul>
				</section>
			</div>
		</div>

		<script src="../lib/js/head.min.js"></script>
		<script src="../js/reveal.js"></script>
		<script src="../js/swift.js"></script>

		<svg height="0" xmlns="http://www.w3.org/2000/svg">
		    <filter id="drop-shadow">
		        <feGaussianBlur in="SourceAlpha" stdDeviation="4"/>
		        <feOffset dx="12" dy="12" result="offsetblur"/>
		        <feFlood flood-color="rgba(0,0,0,0.5)"/>
		        <feComposite in2="offsetblur" operator="in"/>
		        <feMerge>
		            <feMergeNode/>
		            <feMergeNode in="SourceGraphic"/>
		        </feMerge>
		    </filter>
		</svg>

<svg width="480px" height="480px" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <defs>Swift-logo</defs>
    <path d="M42.9,59.7 L15.7,59.7 C10.2,59.7 5.7,55.2 5.7,49.7 L5.7,22.7 C5.7,17.2 10.2,12.7 15.7,12.7 L42.8,12.7 C48.3,12.7 52.8,17.2 52.8,22.7 L52.8,49.8 C52.9,55.2 48.4,59.7 42.9,59.7 L42.9,59.7 Z" id="Shape" stroke="none" fill="#EF5138" fill-rule="evenodd"></path>
    <path d="M42.8,41.7 L42.8,41.7 C42.8,41.5 42.9,41.3 42.9,41.2 C44.9,33.4 40.1,24.2 32,19.4 C35.5,24.2 37.1,30 35.7,35.1 C35.6,35.6 35.4,36 35.3,36.4 C35.1,36.3 34.9,36.2 34.6,36 C34.6,36 26.6,31 17.9,22.3 C17.7,22.1 22.5,29.3 28.1,35.1 C25.5,33.6 18.2,28.4 13.7,24.2 C14.3,25.1 14.9,26 15.7,26.9 C19.5,31.8 24.5,37.8 30.5,42.4 C26.3,45 20.3,45.2 14.4,42.4 C12.9,41.7 11.6,40.9 10.3,39.9 C12.8,43.9 16.7,47.4 21.4,49.4 C27,51.8 32.6,51.6 36.7,49.4 L36.7,49.4 C38.4,48.3 43,46.6 45.3,51.1 C45.7,52 46.8,46.7 42.8,41.7 L42.8,41.7 Z" id="Shape" stroke="none" fill="#FFFFFF" fill-rule="evenodd"></path>
</svg>
	</body>
</html>
