<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Swift-CS333. Swift Syntax</title>

		<link rel="stylesheet" href="../css/reveal.css">
		<link rel="stylesheet" href="../css/theme/swift.css">
		<!-- Theme used for syntax highlighting of code included in main theme -->
		<!-- Printing and PDF exports -->
		<script type="text/javascript">
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? '../css/print/pdf.css' : '../css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
 		</script>
		<style>
			#swift-bird{
				-webkit-clip-path: polygon(10% 0%, 65% 0, 85% 100%, 30% 100%);
				clip-path: polygon(10% 0%, 65% 0, 85% 100%, 30% 100%);
				max-width:100%;
				/*max-height: 100%*/
			}
		</style>
	</head>
	<body>
		<div class="reveal">
			<div class="topbar">
				<div class="breadcrumbs">
				</div>
			</div>
			<div class="slides">
				<section>
					<h2><a href="https://xivol.github.io/Swift-CS333/">CS333</a></h2>
					<h1>Mobile Development</h1>
					<p>
						</br>Ilya Loshkarev</br>
						<a href="mailto:loshkarev.i@gmail.com">loshkarev.i@gmail.com</a>
					</p>
					<p class="footer">
						<br>SFEDU 2017
					</p>
				</section>
				<section>
					<h3 class="hidden">Overview</h3>
					<div class="row">
						<div class="col">
							<ul>
								<li>
									<a href="#/2">Functions</a>
								</li>
								<li>
									<a href="#/3">Closures</a>
								</li>
								<li>
									<a href="#/4">Collections</a>
								</li>
								<li>
									<a href="#/6">Classes</a>
								</li>
								<li>
									<a href="#/7">Error Handling</a>
								</li>
							</ul>
						</div>
						<div class="col">
							<img id="swift-bird" src="../img/swift-bird.jpg" />
						</div>
					</div>
				</section>
<!-- Functions    -->
        <section>
          <section data-background="../img/swift-og.png">
            <h1>Functions</h1>
          </section>
          <section>
            <h3>Argument labels and Parameter names</h3>
            <pre><code data-noheader>
              func greet(person name: String, from hometown: String) -> String {
                return "Hello, \(name)! Glad you could visit from \(hometown)!"
              }
              print(greet(person: "Ivan", from: "Rostov"))
            </code></pre>
            <p>
              You can ommit a label by using <code class="hljs-number">_</code>
            </p>
            <pre><code data-noheader>
              func greet(_ name: String, _ hometown: String) -> String {
                return "Hello, \(name)! Glad you could visit from \(hometown)!"
              }
              print(greet("Ivan", "Rostov"))
            </code></pre>
            <p>
              Labels allow function to be called in an expressive manner
            </p>
            <p class="notice">
              Think hard before you ommit an argument label
            </p>
          </section>
          <section>
            <h3>In-Out parameters</h3>
            <pre><code data-noheader>
              func swapTwo(_ a: inout Int, _ b: inout Int){
                let c = a; a = b; b = c
              }
              var a = 1, b = 2
              swapTwo(&amp;a, &amp;b)
            </code></pre>
            <p>
              All parameters are constant by default
            </p>
            <p class="notice">
              Swift doesn't encourage functions with side effect
            </p>
          </section>
          <section>
            <h3>Function Types</h3>
            <pre><code data-noheader>
              func add(_ a: Int, _ b: Int) -> Int {
                return a + b;
              }
              func mult(_ a:  Int, _ b: Int) -> Int {
                return a * b;
              }
              func calc (_ op: (Int, Int) -> Int, _ a: Int, _ b: Int)) {
                print(op(a, b))
              }
              let a = 5, b = 6
              calc(add, a, b)
              calc(mult, a, b)
            </code></pre>
            <p>
              Function's type consists of <br> types of parameters and return value
            </p>
          </section>
					<section>
						<h3>Operators</h3>
						<pre><code data-noheader>
							func +(_ left: Bool, _ right: Bool) {
								return left || right
							}
							let a = true, b = false
							let c = a + b
						</code></pre>
					</section>
          <section>
            <h3>Nested Functions</h3>
            <pre><code data-noheader>
              func counter(forward: Bool) -> (Int) -> Int {
                func stepForward(input: Int) -> Int {
                  return input + 1
                }
                func stepBackward(input: Int) -> Int {
                  return input - 1
                }

                return forward ? stepForward : stepBackward
              }
            </code></pre>
          </section>
        </section>
<!-- Closures     -->
        <section>
          <section data-background="../img/swift-og.png">
            <h1>Closures</h1>
          </section>
          <section>
            <h3>Closing over context</h3>
            <pre><code data-noheader>
              func counter(increment: Int, forward: Bool) -> (Int) -> Int {

                func backward(input: Int) -> Int {
                  return input - increment
                }

                return !forward ? backward :
                  { (input: Int) -> Int in return input + increment }
              }
            </code></pre>
            <p>
              Closures are blocks of code that can capture <br>local constants and variables
            </p>
          </section>
          <section>
            <h3>Local context</h3>
            <pre><code data-noheader>
              // global function
              func counter(increment: Int, forward: Bool) -> (Int) -> Int {
                // local function &ndash; increment is captured
                func backward(input: Int) -> Int {
                  return input - increment
                }

                return !forward ? backward :
                // closure expression &ndash; increment is captured
                  { (input: Int) -> Int in return input + increment }
              }
            </code></pre>
            <p>
              Local functions and closure expressions <br>can capture any value in context
            </p>
            <p>
              Global functions don't capture any values
            </p>
          </section>
          <section>
            <h3>Closure Expression</h3>
            <pre><code data-noheader>
              let names = ["Anna", "Ivan", "Maria", "John"]

              var reversedNames = names.sorted(by: {
                  (s1: String, s2: String) -> Bool in
                    return s1 > s2
              })
            </code></pre>
            <p>
              Closure expression &ndash; unnamed block of executable code <br> that can capture values from local context
            </p>
          </section>
          <section>
            <h3>Brevity of a closure</h3>
            <div class="row">
              <pre><code data-noheader>
                var reversedNames = names.sorted(by:
                  { s1, s2 in return s1 > s2 })
              </code></pre>
              <p>
                Parameter types can be inferred from context
              </p>
            </div>
            <div class="row">
              <pre><code data-noheader>
                var reversedNames = names.sorted(by: { return $0 > $1 })
              </code></pre>
              <p>
                Parameters can be referenced by shorthand names
              </p>
            </div>
            <div class="row">
              <pre><code data-noheader>
                var reversedNames = names.sorted(by: { $0 > $1 })
              </code></pre>
              <p>
                Single-expression closure implicitly returns its result
              </p>
            </div>
          </section>
          <section>
            <h3>Even shorter</h3>
						<div class="row">
	            <pre><code data-noheader>
	              var reversedNames = names.sorted { $0 > $1 }
	            </code></pre>
	            <p>
	              Closure can be passed with trailing syntax
	            </p>
						</div>
						<div>
	            <pre><code data-noheader>
	              var reversedNames = names.sorted(by: >)
	            </code></pre>
	            <p>
	              Any operator is a closure
	            </p>
						</div>
          </section>
          <section>
            <h3>Sharing a variable</h3>
            <pre><code data-noheader>
              func counter(withIncrement: Int) -> () -> Int {
                var totalCount = 0
                return { totalCount += withIncrement }
              }

              let newCounter = counter(withIncrement: 10)
              print(newCounter()) // 10
              let anotherCounter = newCounter
              print(anotherCounter()) // 20
            </code></pre>
            <p class = "notice">
              Closures are reference type
            </p>
          </section>
          <section>
            <h3>Autoclosures</h3>
            <pre><code data-noheader>
              var names = ["Anna", "Ivan", "Maria", "John"]
              let nextInLine = { names.remove(at:0) }

              print("Next one is \(nextInLine()!") // Anna!
              print(names.count) // 3

              func whosNext(provider nextInLine: @autoclosure () -> String) {
                print("Next one is \(nextInLine())")
              }
              whosNext(provider: names.remove(at:0))
            </code></pre>
            <p>
              <code class="hljs-attribute">@autoclosure</code> automaticaly wraps parameter <br> in closure expression
            </p>
          </section>
        </section>
<!-- Collections  -->
				<section>
					<section data-background="../img/swift-og.png">
						<h1>Collections</h1>
					</section>
					<section>
						<h3>Bridging to Obective-C</h3>
						<div class="row">
							<div class="col">
								<ul>
									<li>String</li>
									<li>Array</li>
									<li>Dictionary</li>
									<li>Set</li>
								</ul>
							</div>
							<div class="col">
								<ul>
									<li>←</li>
									<li>←</li>
									<li>←</li>
									<li>←</li>
								</ul>
							</div>
							<div class="col">
								<ul>
									<li>NSString</li>
									<li>NSArray</li>
									<li>NSDictionary</li>
									<li>NSSet</li>
								</ul>
							</div>
						</div>
							<p>
								 Global functions and interfaces from NSFoundation <br> are availiable in Swift
							</p>
					</section>
					<section>
						<h3>String Views</h3>
						<pre><code data-noheader>
							let flag = "🇷🇺"
							print(flag.characters.count)	// Charcter View
							// Prints "1"
							print(flag.unicodeScalars.count) // Unicode View
							// Prints "2"
							print(flag.utf16.count)		// UTF-16 View
							// Prints "4"
							print(flag.utf8.count)		// UTF-8 View
							// Prints "8"
						</code></pre>
						<p class="notice">
							Each view has its own indices
						</p>
					</section>
					<section>
						<h3>String Index</h3>
						<pre><code data-noheader>
							let start = str.startIndex
							let end = str.endIndex
							let range = start.successor()..&lt;end.advancedBy(-2)
							str.replaceRange(range, with: " swift ")
						</code></pre>
					</section>
					<section>
						<h3>Array</h3>
						<pre><code data-noheader>
							var doubles: [Double] = []
							var emptyFloats: Array<Float> = Array()
							doubles.append(contentsOf: [3.0, 2.0, 1.0])
							doubles += [0.0, -1.0]
							var index = doubles.index(of: 2.0)
							for number in doubles {
								print("\(number)")
							}
						</code></pre>
					</section>
					<section>
						<h3>Dictionary</h3>
					</section>
					<section>
						<h3>Set</h3>
					</section>
				</section>
<!-- Classes      -->
				<section>
          <section data-background="../img/swift-og.png">
            <h1>Classes</h1>
          </section>
					<section>
						<h3>Classes and Structures</h3>
						<pre><code data-noheader>
							struct Point {
								var x = 0.0, y = 0.0
							}

							class Polygon {
								let points: [Point]
								init (_ points: [Point]) {
									self.points = points
								}
								var center: Point {
									/* Calculate center */
									return Point(x: xVal, y:yVal)
								}
							}
						</code></pre>
						<p>
							Classes are reference type
						</p>
						<p>
							Structures are value type and can not be inherited
						</p>
					</section>
					<section>
						<h3>Properties</h3>
						<pre><code data-noheader>
							class Polygon {
								let points: [Point]  // has to be set in initializer
								let name = "polygon" // has a default value
								var area: Double {  // read-only property
									/* Calculate area */
								}
								var origin: Point {
									get {/* do something */}
									set(newOrigin) {/* do something */}
								}
							}
						</code></pre>
					</section>
					<section>
						<h3>Methods</h3>
						<pre><code data-noheader>
							struct Point {
								mutating func offset(_ xStep: Double, _  yStep: Double) {
									/* Change x, y */
								}
								func distance(_ to: Point) -> Double {
									/* Calculate distance */
								}
							}
							class Polygon {
								func contains(_ p: Point) -> Bool {
									/* do something */
								}
							}
						</code></pre>
						<p>
							Structure methods that change properties has to be marked <code class="hljs-keyword">mutating</code>
						</p>
					</section>
					<section>
						<h3>Access Control</h3>
						<pre><code data-noheader>
							class Shady { // implicitly internal
								 private var things: [String] = []
								 private func stuff() {}
								 func allClear() {} // implicitly internal
								 public var totallyClear: String
							}
							private class Classified { // explicitly private
								var nothing: String // implicitly private
							}
						</code></pre>
						<p class="notice">
							All classes and class members are implicitly <code class="hljs-keyword">internal</code>
						</p>
					</section>
					<section>
						<h3>Automatic Reference Counting</h3>
						<pre><code data-noheader>
							class ARCout {
								init(){
									print ("initialized")
								}
								deinit() {
									print ("deinitialized")
								}
							}
							var reference1: ARCout? = ARCout() // initialized
							var reference2 = reference1
							reference1 = nil
							reference2 = nil // deinitialized
						</code></pre>
						<p>
							Deallocates memory if no references to object exists
						</p>
					</section>
					<section>
						<h3>Reference Loops</h3>
						<pre><code data-noheader>
							class ARCout {
								var reference: ARCout?
							}
							var obj1 = ARCout() // initialized
							var obj2 = ARCout() // initialized
							obj1.reference = obj2
							obj2.reference = obj1
							obj1 = nil
							obj2 = nil
							// But nothing happened!
						</code></pre>
						<pre><code data-noheader>
							class ARCout {
								weak var reference: ARCout?
							}
						</code></pre>
						<p>
							<code class="hljs-keyword">weak</code> references don't increase retain count
						</p>
						<p>
							<code class="hljs-keyword">unowned</code> references don't have to be optional values
						</p>
					</section>
					<section>
						<h3>Inheritance</h3>
						<pre><code data-noheader>
							class Triangle: Polygon {
								init(_ a: Point, _ b: Point, _ c: Point) {
									let verts = [a,b,c]
									super.init(verts)
									name = "triangle"
								}
								override var area: Double {
									/* Calculate area */
								}
								func inradius: Double {
									/* Calculate incircle radius */
								}
							}
						</code></pre>
						<p>
							<code class="hljs-keyword">super</code> provides access to superclass members
						</p>
						<p class="notice">
							Any overwritten member should be marked with <code class="hljs-keyword">override</code>
						</p>
					</section>
					<section>
						<h3>Type Casting</h3>
						<pre><code data-noheader>
							let shapes = [Polygon]()
							/* appended something to shapes */
							for shape in shapes {
								if shape is Triangle {
									print("it's a triangle")
								}
							}

							for shape in shapes {
								if let tri = shape as? Triangle {
									print(tri.inradius)
								}
							}
							</code></pre>
							<p>
								<code class="hljs-keyword">as?</code> wraps result into optional,	<br> returns <code class="hljs-literal">nil</code> if variable cannot be downcasted
							</p>
							<p>
								<code class="hljs-keyword">as!</code> triggers a runtime error instead
							</p>
					</section>
        </section>
<!-- Error Handling -->
				<section>
					<section data-background="../img/swift-og.png">
						<h1>Error Handling</h1>
					</section>
					<section>
						<h3>Throwing Errors</h3>
						<pre><code data-noheader>
							enum MyErrors: ErrorType {
								case OutOfOptions
							}
							func chooseOption() throws -> Int {
								throw MyErrors.OutOfOptions
							}
						</code></pre>
						<p>
							<code class="hljs-type">ErrorType</code> &ndash; empty protocol for declaring errors
						</p>
						<p class="notice">
							Only throwing functions can throw and propagate errors
						</p>
					</section>
					<section>
						<h3>Catching Errors</h3>
						<pre><code data-noheader>
							do {
								var option = try chooseOption()
							}
							catch MyErrors.OutOfOptions {
								print("I'm all out of options here!")
							}
						</code></pre>
						<p>
							<code class="hljs-keyword">try</code> can only be used in <code class="hljs-keyword">do-catch</code> block
						</p>
						<p>
							<code class="hljs-keyword">do-catch</code> block stops error propagation <br> if it catches an error
						</p>
					</section>
					<section>
						<h3>Other Options</h3>
						<pre><code data-noheader>
							var option = try? chooseOption() // Int?

							func makeAnOption() -> Int {
								var option = try! chooseOption() // just do it
								return option
							}
						</code></pre>
						<p>
							<code class="hljs-keyword">try?</code> wraps value into an optinal, retruns <code class="hljs-literal">nil</code> if error occurs
						</p>
						<p>
							<code class="hljs-keyword">try!</code> fails here and now, stops error popagation
						</p>
					</section>
					<section>
						<h3>Guard</h3>
						<pre><code data-noheader>
							guard let option = try? chooseOption() else {
								print("Sorry, we're out of options!")
								return
							}
							print("Congratulations, your option is \(option)")
						</code></pre>
						<p>
							<code class="hljs-keyword">guard</code> is assert-like operator that allow quick escape <br> if condition is not met
						</p>
						<p class = "notice">
							guard-bound optional is accesible outside of it's else clause
						</p>
					</section>
				</section>
<!-- Resources			-->
				<section>
					<h3 style="display:none;">Related Resources</h3>
					<ul>
						<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html">Swift Programming Language - Apple Developer</a>
						</li>
						<li><a href="https://developer.apple.com/reference/swift">Swift Standart Library - Apple Developer</a>
						</li>
						<li><a href="https://developer.apple.com/reference/foundation">Foundation - API Reference</a>
					</ul>
				</section>
			</div>
		</div>

		<script src="../lib/js/head.min.js"></script>
		<script src="../js/reveal.js"></script>
		<script src="../js/swift.js"></script>

		<svg height="0" xmlns="http://www.w3.org/2000/svg">
		    <filter id="drop-shadow">
		        <feGaussianBlur in="SourceAlpha" stdDeviation="4"/>
		        <feOffset dx="12" dy="12" result="offsetblur"/>
		        <feFlood flood-color="rgba(0,0,0,0.5)"/>
		        <feComposite in2="offsetblur" operator="in"/>
		        <feMerge>
		            <feMergeNode/>
		            <feMergeNode in="SourceGraphic"/>
		        </feMerge>
		    </filter>
		</svg>

<svg width="480px" height="480px" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <defs>Swift-logo</defs>
    <path d="M42.9,59.7 L15.7,59.7 C10.2,59.7 5.7,55.2 5.7,49.7 L5.7,22.7 C5.7,17.2 10.2,12.7 15.7,12.7 L42.8,12.7 C48.3,12.7 52.8,17.2 52.8,22.7 L52.8,49.8 C52.9,55.2 48.4,59.7 42.9,59.7 L42.9,59.7 Z" id="Shape" stroke="none" fill="#EF5138" fill-rule="evenodd"></path>
    <path d="M42.8,41.7 L42.8,41.7 C42.8,41.5 42.9,41.3 42.9,41.2 C44.9,33.4 40.1,24.2 32,19.4 C35.5,24.2 37.1,30 35.7,35.1 C35.6,35.6 35.4,36 35.3,36.4 C35.1,36.3 34.9,36.2 34.6,36 C34.6,36 26.6,31 17.9,22.3 C17.7,22.1 22.5,29.3 28.1,35.1 C25.5,33.6 18.2,28.4 13.7,24.2 C14.3,25.1 14.9,26 15.7,26.9 C19.5,31.8 24.5,37.8 30.5,42.4 C26.3,45 20.3,45.2 14.4,42.4 C12.9,41.7 11.6,40.9 10.3,39.9 C12.8,43.9 16.7,47.4 21.4,49.4 C27,51.8 32.6,51.6 36.7,49.4 L36.7,49.4 C38.4,48.3 43,46.6 45.3,51.1 C45.7,52 46.8,46.7 42.8,41.7 L42.8,41.7 Z" id="Shape" stroke="none" fill="#FFFFFF" fill-rule="evenodd"></path>
</svg>
	</body>
</html>
