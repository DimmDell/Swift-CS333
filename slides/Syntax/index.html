<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Swift-CS333. Swift Syntax</title>

		<link rel="stylesheet" href="../css/reveal.css">
		<link rel="stylesheet" href="../css/theme/swift.css">
		<!-- Theme used for syntax highlighting of code included in main theme -->
		<!-- Printing and PDF exports -->
		<script type="text/javascript">
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? '../css/print/pdf.css' : '../css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
 		</script>

	</head>
	<body>
		<div class="reveal">
			<div class="topbar">
				<div class="breadcrumbs">
				</div>
			</div>
			<div class="slides">
				<section>
					<h2>CS333</h2>
					<h1>Mobile Development</h1>
					<p>
						</br>Ilya Loshkarev</br>
						<a href="mailto:loshkarev.i@gmail.com">loshkarev.i@gmail.com</a>
					</p>
					<p class="footer">
						<br>SFEDU 2016
					</p>
				</section>
<!-- Swift Basics			-->
				<section class="">
					<section data-background="../img/swift-og.png">
						<h1>The Basics</h1>
					</section>
					<section>
						<h3>Constants and Variables</h3>
						<pre><code data-noheader>
							let pi = 3.14
							var r = 1.0
							while r < 100 {
								let sqr = r * r * pi
								print("Radius: \(r); Square: \(sqr)")
								r += 1
							}
						</code></pre>
						<div class="row">
							<div class="col">
								<code class="hljs-keyword">let</code> decalres a constant
							</div>
							<div class="col">
								<code class="hljs-keyword">var</code> declares a variable
							</div>
						</div>
						<p class="notice">
							Always declare a constant unless absolutely necessary
						</p>
					</section>
					<section>
						<h3>Basic Datatypes</h3>
						<pre><code data-noheader>
							let i: Int = 1  // default Int is either Int32 or Int64
							let f: Float = 2.7
							let d: Double = 3.1
							let b: Bool = true
							let s: String = "hello"
						</code></pre>
						<p>
							Swift can infer type of a variable
						</p>
						<pre><code data-noheader>
								let x = 5, y = 3.142, z = true
								let names = ["Alex", "Anna", "Ivan", "Maria"]
						</code></pre>
					</section>
					<section>
						<h3>Type Conversion</h3>
						<p>
							Swift is type-safe language
						</p>
						<pre><code data-noheader>
							var pi = 3 + 0.14 // literals don't have explicit type
							let three = 3
							let pointOneFour = 0.14
							pi = Double(three) + pointOneFour
							// implicit type conversions are not allowed
							let roundPi:Int = Int(pi)
						</code></pre>
						<p class="notice">
							All type conversions must be explicit
						</p>
					</section>
					<section>
						<h3>Functions</h3>
						<pre><code data-noheader>
							func greet(person: String, from hometown: String) -> String {
								return "Hello, \(person)! Glad you could visit from \(hometown)!"
							}

							print(greet(person: "Ivan", from: "Rostov"))
						</code></pre>
						<p>
							Every parameter has a name and an argument label
						</p>
						<p class="notice">
							Arguments must be labeled when function is called
						</p>
					</section>
					<section>
						<h3>Optionals</h3>
						<pre><code data-noheader>
							let someNum = "3.14"
							let number = Double(someNum) // Double?
							if number != nil {
								print("parsed number: \(number!)") // unwraped value is 3.14
							}
						</code></pre>
						<p>
							Optional value contains either value or <code class="hljs-literal">nil</code>
						</p>
						<p class="notice">Always make sure optional contains a value before foced unwraping</p>
					</section>
					<section>
						<h3>Conditional Statement</h3>
						<pre><code data-noheader>
							let someChar: Character = "z"
							if someChar >= "0" &amp;&amp; someChar <= "9" {
								print("This is a digit.")
							} else if someChar >= "a" &amp;&amp; someChar <= "z" {
								print("This is a letter.")
							}
						</code></pre>
						<p class="notice">
							Curved braces are required
						</p>
					</section>
					<section>
						<h3>Optional Binding</h3>
						<pre><code data-noheader>
							let someNum = "3.14"
							if let number = Double(someNum) { // number is Double!
								print("parsed number: \(number)")
							} else {
								print("\(someNum) is not a number") // number is not reachable
							}
						</code></pre>
						<p class="notice">
							Bound optional always contains a value
						</p>
					</section>
					<section>
						<h3>Conditional Statement &ndash; Switch</h3>
						<pre><code data-noheader>
							let someChar: Character = "z"
							switch (someChar) {
								case "a":
									print("It is the first letter of the alphabet")
								case "b"..."y":
									print("It is some other letter of the alphabet")
								case "z":
									print("It is the last letter of the alphabet")
								default:
									print("It is some other character")
							}
						</code></pre>
						<p class="notice">
							Case must always have a body
						</p>
					</section>
          <section>
            <h3>Loops</h3>
            <div class="row">
  						<div class="col"><pre><code data-noheader>
  							var i = 0
  							while i < 5 {
  								i += 1
  							}
  							repeat {
  								i -= 1
  							} while i > 0
              </code></pre></div>
  						<div class="col"><pre><code data-noheader>
  							for i in 0...10 {
  								for j in 0...i {
  									print(".")
  								}
  								print("\n")

  							}
              </code></pre></div>
            </div>
          </section>
				</section>
<!-- Functions      -->
        <section>
          <section data-background="../img/swift-og.png">
            <h1>Functions</h1>
          </section>
          <section>
            <h3>Argument labels and Parameter names</h3>
            <pre><code data-noheader>
              func greet(person name: String, from hometown: String) -> String {
                return "Hello, \(name)! Glad you could visit from \(hometown)!"
              }
              print(greet(person: "Ivan", from: "Rostov"))
            </code></pre>
            <p>
              You can ommit a label by using <code class="hljs-number">_</code>
            </p>
            <pre><code data-noheader>
              func greet(_ name: String, _ hometown: String) -> String {
                return "Hello, \(name)! Glad you could visit from \(hometown)!"
              }
              print(greet("Ivan", "Rostov"))
            </code></pre>
            <p>
              Labels allow function to be called in an expressive manner
            </p>
            <p class="notice">
              Think hard before you ommit an argument label
            </p>
          </section>
          <section>
            <h3>In-Out parameters</h3>
            <pre><code data-noheader>
              func swapTwo(_ a: inout Int, _ b: inout Int){
                let c = a; a = b; b = c
              }
              var a = 1, b = 2
              swapTwo(&amp;a, &amp;b)
            </code></pre>
            <p>
              All parameters are constant by default
            </p>
            <p class="notice">
              Swift doesn't encourage functions with side effect
            </p>
          </section>
          <section>
            <h3>Function Types</h3>
            <pre><code data-noheader>
              func add(_ a: Int, _ b: Int) -> Int {
                return a + b;
              }
              func mult(_ a:  Int, _ b: Int) -> Int {
                return a * b;
              }
              func calc (_ op: (Int, Int) -> Int, _ a: Int, _ b: Int)) {
                print(op(a, b))
              }
              let a = 5, b = 6
              calc(add, a, b)
              calc(mult, a, b)
            </code></pre>
            <p>
              Function's type consists of <br> types of parameters and return value
            </p>
          </section>
					<section>
						<h3>Operators</h3>
						<pre><code data-noheader>
							func +(_ left: Bool, _ right: Bool) {
								return left || right
							}
							let a = true, b = false
							let c = a + b
						</code></pre>
					</section>
          <section>
            <h3>Nested Functions</h3>
            <pre><code data-noheader>
              func counter(forward: Bool) -> (Int) -> Int {
                func stepForward(input: Int) -> Int {
                  return input + 1
                }
                func stepBackward(input: Int) -> Int {
                  return input - 1
                }

                return forward ? stepForward : stepBackward
              }
            </code></pre>
          </section>
        </section>
<!-- Closures			-->
        <section>
          <section data-background="../img/swift-og.png">
            <h1>Closures</h1>
          </section>
          <section>
            <h3>Closing over context</h3>
            <pre><code data-noheader>
              func counter(increment: Int, forward: Bool) -> (Int) -> Int {

                func backward(input: Int) -> Int {
                  return input - increment
                }

                return !forward ? backward :
                  { (input: Int) -> Int in return input + increment }
              }
            </code></pre>
            <p>
              Closures are blocks of code that can capture <br>local constants and variables
            </p>
          </section>
          <section>
            <h3>Local context</h3>
            <pre><code data-noheader>
              // global function
              func counter(increment: Int, forward: Bool) -> (Int) -> Int {
                // local function &ndash; increment is captured
                func backward(input: Int) -> Int {
                  return input - increment
                }

                return !forward ? backward :
                // closure expression &ndash; increment is captured
                  { (input: Int) -> Int in return input + increment }
              }
            </code></pre>
            <p>
              Local functions and closure expressions <br>can capture any value in context
            </p>
            <p>
              Global functions don't capture any values
            </p>
          </section>
          <section>
            <h3>Closure Expression</h3>
            <pre><code data-noheader>
              let names = ["Anna", "Ivan", "Maria", "John"]

              var reversedNames = names.sorted(by: {
                  (s1: String, s2: String) -> Bool in
                    return s1 > s2
              })
            </code></pre>
            <p>
              Closure expression &ndash; unnamed block of executable code <br> that can capture values from local context
            </p>
          </section>
          <section>
            <h3>Brevity of a closure</h3>
            <div class="row">
              <pre><code data-noheader>
                var reversedNames = names.sorted(by:
                  { s1, s2 in return s1 > s2 })
              </code></pre>
              <p>
                Parameter types can be inferred from context
              </p>
            </div>
            <div class="row">
              <pre><code data-noheader>
                var reversedNames = names.sorted(by: { return $0 > $1 })
              </code></pre>
              <p>
                Parameters can be referenced by shorthand names
              </p>
            </div>
            <div class="row">
              <pre><code data-noheader>
                var reversedNames = names.sorted(by: { $0 > $1 })
              </code></pre>
              <p>
                Single-expression closure implicitly returns its result
              </p>
            </div>
          </section>
          <section>
            <h3>Even shorter</h3>
						<div class="row">
	            <pre><code data-noheader>
	              var reversedNames = names.sorted { $0 > $1 }
	            </code></pre>
	            <p>
	              Closure can be passed with trailing syntax
	            </p>
						</div>
						<div>
	            <pre><code data-noheader>
	              var reversedNames = names.sorted(by: >)
	            </code></pre>
	            <p>
	              Any operator is a function
	            </p>
						</div>
          </section>
          <section>
            <h3>Sharing a variable</h3>
            <pre><code data-noheader>
              func counter(withIncrement: Int) -> () -> Int {
                var totalCount = 0
                return { totalCount += withIncrement }
              }

              let newCounter = counter(withIncrement: 10)
              print(newCounter()) // 10
              let anotherCounter = newCounter
              print(anotherCounter()) // 20
            </code></pre>
            <p class = "notice">
              Closures are reference type
            </p>
          </section>
          <section>
            <h3>Autoclosures</h3>
            <pre><code data-noheader>
              var names = ["Anna", "Ivan", "Maria", "John"]
              let nextInLine = { names.remove(at:0) }

              print("Next one is \(nextInLine()!") // Anna!
              print(names.count) // 3

              func whosNext(provider nextInLine: @autoclosure () -> String) {
                print("Next one is \(nextInLine())")
              }
              whosNext(provider: names.remove(at:0))
            </code></pre>
            <p>
              <code class="hljs-attribute">@autoclosure</code> automaticaly wraps parameter <br> in closure expression
            </p>
          </section>
        </section>
<!-- Classes      -->
				<section>
          <section data-background="../img/swift-og.png">
            <h1>Classes</h1>
          </section>
					<section>
						<h3>Classes and Structures</h3>
						<pre><code data-noheader>
							struct Point {
								var x = 0.0, y = 0.0
							}

							class Polygon {
								let points: [Point]
								init (_ points: [Point]) {
									self.points = points
								}
								var center: Point {
									/* Calculate center */
									return Point(x: xVal, y:yVal)
								}
							}
						</code></pre>
						<p>
							Classes are reference type
						</p>
						<p>
							Structures are value type and can not be inherited
						</p>
					</section>
					<section>
						<h3>Properties</h3>
						<pre><code data-noheader>
							class Polygon {
								let points: [Point]  // has to be set in initializer
								let name = "polygon" // has a default value
								var area: Double {  // read-only property
									/* Calculate area */
								}
								var origin: Point {
									get {/* do something */}
									set(newOrigin) {/* do something */}
								}
							}
						</code></pre>
					</section>
					<section>
						<h3>Methods</h3>
						<pre><code data-noheader>
							struct Point {
								mutating func offset(_ xStep: Double, _  yStep: Double) {
									/* Change x, y */
								}
								func distance(_ to: Point) -> Double {
									/* Calculate distance */
								}
							}
							class Polygon {
								func contains(_ p: Point) -> Bool {
									/* do something */
								}
							}
						</code></pre>
						<p>
							Structure methods that change properties has to be marked <code class="hljs-keyword">mutating</code>
						</p>
					</section>
					<section>
						<h3>Access Control</h3>
						<pre><code data-noheader>
							class Shady { // implicitly internal
								 private var things: [String] = []
								 private func stuff() {}
								 func allClear() {} // implicitly internal
								 public var totallyClear: String
							}
							private class Classified { // explicitly private
								var nothing: String // implicitly private
							}
						</code></pre>
						<p class="notice">
							All classes and class members are implicitly <code class="hljs-keyword">internal</code>
						</p>
					</section>
					<section>
						<h3>Automatic Reference Counting</h3>
						<pre><code data-noheader>
							class ARCout {
								init(){
									print ("initialized")
								}
								deinit() {
									print ("deinitialized")
								}
							}
							var reference1: ARCout? = ARCout() // initialized
							var reference2 = reference1
							reference1 = nil
							reference2 = nil // deinitialized
						</code></pre>
						<p>
							Deallocates memory if no references to object exists
						</p>
					</section>
					<section>
						<h3>Reference Loops</h3>
						<pre><code data-noheader>
							class ARCout {
								var reference: ARCout?
							}
							var obj1 = ARCout() // initialized
							var obj2 = ARCout() // initialized
							obj1.reference = obj2
							obj2.reference = obj1
							obj1 = nil
							obj2 = nil
							// But nothing happened!
						</code></pre>
						<pre><code data-noheader>
							class ARCout {
								weak var reference: ARCout?
							}
						</code></pre>
						<p>
							<code class="hljs-keyword">weak</code> references don't increase retain count
						</p>
						<p>
							<code class="hljs-keyword">unowned</code> references don't have to be optional values
						</p>
					</section>
					<section>
						<h3>Inheritance</h3>
						<pre><code data-noheader>
							class Triangle: Polygon {
								init(_ a: Point, _ b: Point, _ c: Point) {
									let verts = [a,b,c]
									super.init(verts)
									name = "triangle"
								}
								override var area: {
									/* Calculate area */
								}
								override func contains(_ p: Point) -> Bool {
									/* do something */
								}
							}
						</code></pre>
					</section>
        </section>
<!-- Error Handling -->
				<section>
					<section data-background="../img/swift-og.png">
						<h1>Error Handling</h1>
					</section>
					<section>
						<h3>Throwing Errors</h3>
						<pre><code data-noheader>
							enum MyErrors: ErrorType {
								case OutOfOptions
							}
							func chooseOption() throws -> Int {
								throw MyErrors.OutOfOptions
							}
							var option = try? chooseOption()
						</code></pre>
						<p>
							<code>ErrorType</code> &ndash; empty protocol for declaring errors
						</p>
						<p class="notice">
							Only throwing functions can propagate errors
						</p>
					</section>
					<section>
						<h3>Catching Errors</h3>
						<pre><code data-noheader>
						</code></pre>
					</section>
					<section>
						<h3>try try? try!</h3>
					</section>
				</section>
<!-- Resources			-->
				<section>
					<h3 style="display:none;">Related Resources</h3>
					<ul>
						<li><a href="https://swift.org/blog">Swift Blog</a>
						</li>
						<li><a href="https://developer.apple.com/swift/resources/">Swift Resources - Apple Developer</a>
						</li>
					</ul>
				</section>
			</div>
		</div>

		<script src="../lib/js/head.min.js"></script>
		<script src="../js/reveal.js"></script>
		<script src="../js/swift.js"></script>

		<svg height="0" xmlns="http://www.w3.org/2000/svg">
		    <filter id="drop-shadow">
		        <feGaussianBlur in="SourceAlpha" stdDeviation="4"/>
		        <feOffset dx="12" dy="12" result="offsetblur"/>
		        <feFlood flood-color="rgba(0,0,0,0.5)"/>
		        <feComposite in2="offsetblur" operator="in"/>
		        <feMerge>
		            <feMergeNode/>
		            <feMergeNode in="SourceGraphic"/>
		        </feMerge>
		    </filter>
		</svg>

<svg width="480px" height="480px" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <defs>Swift-logo</defs>
    <path d="M42.9,59.7 L15.7,59.7 C10.2,59.7 5.7,55.2 5.7,49.7 L5.7,22.7 C5.7,17.2 10.2,12.7 15.7,12.7 L42.8,12.7 C48.3,12.7 52.8,17.2 52.8,22.7 L52.8,49.8 C52.9,55.2 48.4,59.7 42.9,59.7 L42.9,59.7 Z" id="Shape" stroke="none" fill="#EF5138" fill-rule="evenodd"></path>
    <path d="M42.8,41.7 L42.8,41.7 C42.8,41.5 42.9,41.3 42.9,41.2 C44.9,33.4 40.1,24.2 32,19.4 C35.5,24.2 37.1,30 35.7,35.1 C35.6,35.6 35.4,36 35.3,36.4 C35.1,36.3 34.9,36.2 34.6,36 C34.6,36 26.6,31 17.9,22.3 C17.7,22.1 22.5,29.3 28.1,35.1 C25.5,33.6 18.2,28.4 13.7,24.2 C14.3,25.1 14.9,26 15.7,26.9 C19.5,31.8 24.5,37.8 30.5,42.4 C26.3,45 20.3,45.2 14.4,42.4 C12.9,41.7 11.6,40.9 10.3,39.9 C12.8,43.9 16.7,47.4 21.4,49.4 C27,51.8 32.6,51.6 36.7,49.4 L36.7,49.4 C38.4,48.3 43,46.6 45.3,51.1 C45.7,52 46.8,46.7 42.8,41.7 L42.8,41.7 Z" id="Shape" stroke="none" fill="#FFFFFF" fill-rule="evenodd"></path>
</svg>
	</body>
</html>
